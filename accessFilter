#!/usr/local/bin/python

# is: a filter through which Apache access.log records can be piped to filter
# 	out various categories of records (sending others out to stdout)

import sys
import getopt
import re
import runCommand

USAGE = '''Usage: %s [-r|-s|-i|-m|-g|-v|-b <date>|-a <date>] [-f <filename>] [-o <filename>]
	Serves as a filter for Apache access logs.  Can be used to strip out
	various types of requests, based on command-line flags.

    Filtering options:
	-r : exclude hits from robots
	-s : exclude hits from Perl/Python/Java/etc. scripts
	-i : exclude requests for JPG or GIF images
	-m : exclude hits from MGI machines
	-g : exclude hits for GXD pages (often would use this with -v)
	-v : reverse processing (include only those specified, not exclude)
	-b : exclude hits before a given date (mm/dd/yyyy format)
	-a : exclude hits after a given date (mm/dd/yyyy format)
    File-handling options:
	-f : specify an input file from which to read (default is stdin)
	-o : specify an output file to which to write (default is stdout)
    Notes:
    	1. You must use at least one of -r, -s, -i, -m, -g, -b, and -a.
	2. The -a and -b options do not exclude hits from the specified date.
	3. If you use -a and -b with the same date, you will include only the
	   hits from that specific date.
	4. The -v option will include only those records which would have
	   otherwise been excluded by one or more of the specified criteria.
	   (You will get the set of all those which would be excluded without
	   the -v option.)
''' % sys.argv[0]

INFILE = sys.stdin
OUTFILE = sys.stdout

ROBOTS = False		# boolean flags for which records to exclude
SCRIPTS = False
IMAGES = False
MGI = False
GXD = False

AFTER_DATE = None
BEFORE_DATE = None

REVERSE = False

ROBOT_TAGS = [ 'bot', 'jeeves', 'inktomi', 'crawl', 'webcapture', 'webcopier',
	'slurp', 'spider', ]
SCRIPT_TAGS = [ 'python', 'perl', 'java', 'mfc' ]

# mm/dd/yyyy dates from user
USER_RE = re.compile ('([0-9]{2})/([0-9]{2})/([0-9]{4})')

# dd/mmm/yyyy dates from log entries
LOG_RE = re.compile ('([0-9]{2})/([A-Z][a-z]{2})/([0-9]{4})')

def bailout (s):
	sys.stderr.write (USAGE + '\n')
	if s:
		sys.stderr.write ('Error: %s\n' % s)
	sys.exit(1)

abbrevToStr = {
	'Jan' : '01',
	'Feb' : '02',
	'Mar' : '03',
	'Apr' : '04',
	'May' : '05',
	'Jun' : '06',
	'Jul' : '07',
	'Aug' : '08',
	'Sep' : '09',
	'Oct' : '10',
	'Nov' : '11',
	'Dec' : '12',
	}

def logDate (s):
	global LOG_RE

	match = LOG_RE.search (s)
	if not match:
		bailout ('Invalid dd/mmm/yyyy date string: %s' % s)

	year = match.group(3)
	month = match.group(2)
	day = match.group(1)

	if not abbrevToStr.has_key(month):
		bailout ('Invalid month (%s) in date string: %s' % (month, s))

	return year + abbrevToStr[month] + day

def userDate (s):
	global USER_RE

	match = USER_RE.search (s)
	if not match:
		bailout ('Invalid mm/dd/yyyy date string: %s' % s)

	year = match.group(3)
	month = match.group(1)
	day = match.group(2)

	return year + month + day

def processCommandLine():
	global INFILE, OUTFILE, ROBOTS, SCRIPTS, IMAGES, MGI, REVERSE, GXD
	global AFTER_DATE, BEFORE_DATE

	try:
		options, args = getopt.getopt (sys.argv[1:], 'rsimgvf:o:a:b:')
	except getopt.GetoptError:
		bailout ('Invalid command-line flag(s)')

	if len(args) > 0:
		bailout ('No extra arguments are allowed')

	for (option, value) in options:
		if option == '-r':
			ROBOTS = True
		elif option == '-s':
			SCRIPTS = True
		elif option == '-i':
			IMAGES = True
		elif option == '-m':
			MGI = True
		elif option == '-v':
			REVERSE = True
		elif option == '-f':
			try:
				INFILE = open (value, 'r')
			except:
				bailout ('Cannot read from: %s' % value)
		elif option == '-o':
			try:
				OUTFILE = open (value, 'w')
			except:
				bailout ('Cannot write to: %s' % value)
		elif option == '-a':
			AFTER_DATE = userDate (value)
		elif option == '-b':
			BEFORE_DATE = userDate (value)
		elif option == '-g':
			GXD = True

	if not (ROBOTS or SCRIPTS or MGI or IMAGES or GXD or \
			BEFORE_DATE or AFTER_DATE):
		bailout ('Must use at least one of -r, -s, -i, -m, -g, -a, or -b')
	return

def closeFiles():
	global OUTFILE, INFILE

	if OUTFILE != sys.stdout:
		OUTFILE.close()
	if INFILE != sys.stdin:
		INFILE.close()
	return

def isMgi (ip):
	if ip.startswith('209.222.209'):
	    	return True
	if ip.endswith('informatics.jax.org'):
		return True
	if ip.startswith('wolvecamp'):
		return True
	return False

def isImage (uriLower):
	for suffix in [ '.gif', '.jpg', '.jpeg', '.ico' ]:
		if uriLower.endswith(suffix):
			return True

	if uriLower.find ('string_image.cgi') != -1:
		return True

	return False

ROBOT_IP = {}
NUMERIC_RE = re.compile ('^[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}$')
NAME_RE = re.compile ('Name: *\(.*\)')
RESOLVED = 0
UNIQUE = 0
ROBOT_IPS = 0

def isRobot (ip, agentLower):
	global ROBOT_IP, NUMERIC_RE, NAME_RE, RESOLVED, UNIQUE, ROBOT_IPS

	if ROBOT_IP.has_key(ip):
		# if we know this is a robot based on IP address, just report
		# it.  if the IP hasn't flagged it as a robot, then we need to
		# check the user agent.  (the same computer may use a browser
		# sometimes and use robot/scripting sometimes)

		if ROBOT_IP[ip] == True:
			return True
	else:
		address = ip

		# if is numeric address need to resolve to name using nslookup
		# (if possible)

		if NUMERIC_RE.match(ip):
			UNIQUE = UNIQUE + 1
			(stdout, stderr, exitCode) = runCommand.runCommand (
				'nslookup %s' % ip)

			lines = stdout.split ('\n')
			if (len(lines) >= 4) and (lines[3].find('Name') != -1):
				match = NAME_RE.search (lines[3])
				if match:
					address = match.group(1)
					RESOLVED = RESOLVED + 1

		for tag in ROBOT_TAGS:
			if address.find (tag) != -1:
				ROBOT_IP[ip] = True
				ROBOT_IPS = ROBOT_IPS + 1
				return True

		ROBOT_IP[ip] = False

	# check user agent

	for tag in ROBOT_TAGS:
		if agentLower.find (tag) != -1:
			return True
	return False

def isScript (agentLower):
	for tag in SCRIPT_TAGS:
		if agentLower.find (tag) != -1:
			return True
	return False

def includeDate (dateTime):
	dateStr = logDate(dateTime)
	if AFTER_DATE and dateStr > AFTER_DATE:
		return False
	if BEFORE_DATE and dateStr < BEFORE_DATE:
		return False
	return True 

# strings which identify GXD pages
GXD_TAGS = [ 'expression', 'gxdindex', 'estclone', 'anatdict', 'AMA', 'GEN',
	'markerTissues', 'antibody', 'antigen', '/image.cgi', 'exptools',
	'GXD', 'gxd_tissue_report', 'imageSummaryByMrk', 'ADRefiner',
	'cDNAQF'
	]

def isGxd (uri):
	for tag in GXD_TAGS:
		if uri.find (tag) != -1:
			return True
	return False

def filter():
	global INFILE, OUTFILE

	line = INFILE.readline()
	while line:
		output = True

		fields = line.strip().split(' ')
		numFields = len(fields)

		if ROBOTS or SCRIPTS:
			if numFields >= 12:
				# the agent field is enclosed in quotes and
				# may include spaces, so just put back
				# together everything after field 11; it will
				# be close enough

				agent = ' '.join(fields[11:]).lower()
				if ROBOTS and isRobot(fields[0], agent):
					output = False
				elif SCRIPTS and isScript(agent):
					output = False

		if output and MGI:
			if numFields >= 1:
				if isMgi(fields[0]):
					output = False
		if output and IMAGES:
			if numFields >= 7:
				if isImage(fields[6].lower()):
					output = False

		if output and GXD:
			if numFields >= 7:
				if isGxd(fields[6]):
					output = False

		if output and (BEFORE_DATE or AFTER_DATE):
			if numFields >= 4:
				output = includeDate(fields[3])

		if REVERSE:
			output = not output

		if output:
			OUTFILE.write(line)

		line = INFILE.readline()
	return

def main():
	processCommandLine()
	filter()
	closeFiles()
	if UNIQUE > 0:
		sys.stderr.write ('FYI: Resolved %d of %d IP addresses, %d flagged as robots\n' % (RESOLVED, UNIQUE, ROBOT_IPS))

if __name__ == '__main__':
	main()
